#!/usr/bin/env lua
-- ipcrypt-keygen - Cryptographically secure key generation utility for IPCrypt

-- Add lib to path
local script_dir = arg[0]:match("(.*/)") or ""
package.path = script_dir .. "../lib/?.lua;" .. script_dir .. "../lib/?/init.lua;" .. package.path

local utils = require("ipcrypt.utils")

-- Parse command line arguments
local function print_usage()
    print("IPCrypt Key Generation Utility")
    print("==============================")
    print()
    print("Usage: lua keygen.lua [options]")
    print()
    print("Options:")
    print("  -h, --help           Show this help message")
    print("  -l, --length <size>  Key length in bytes (16 or 32, default: 16)")
    print("  -n, --count <num>    Number of keys to generate (default: 1)")
    print("  -f, --format <fmt>   Output format: hex or base64 (default: hex)")
    print("  --check              Check random source and exit")
    print()
    print("Examples:")
    print("  lua keygen.lua                    # Generate one 16-byte key in hex")
    print("  lua keygen.lua -l 32              # Generate one 32-byte key")
    print("  lua keygen.lua -n 5               # Generate 5 keys")
    print("  lua keygen.lua -l 32 -f base64    # Generate 32-byte key in base64")
    os.exit(0)
end

-- Base64 encoding function
local function base64_encode(data)
    local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    return ((data:gsub('.', function(x) 
        local r, b = '', x:byte()
        for i = 8, 1, -1 do r = r .. (b % 2 ^ i - b % 2 ^ (i - 1) > 0 and '1' or '0') end
        return r
    end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
        if #x < 6 then return '' end
        local c = 0
        for i = 1, 6 do c = c + (x:sub(i, i) == '1' and 2 ^ (6 - i) or 0) end
        return b:sub(c + 1, c + 1)
    end) .. ({ '', '==', '=' })[#data % 3 + 1])
end

-- Parse arguments
local key_length = 16
local count = 1
local format = "hex"
local i = 1

while i <= #arg do
    local a = arg[i]
    
    if a == "-h" or a == "--help" then
        print_usage()
    elseif a == "--check" then
        local source = utils.get_random_source()
        local secure = utils.has_secure_random()
        
        print("Random Source Check")
        print("===================")
        print("Source: " .. source)
        if source == "urandom" then
            print("Status: SECURE (/dev/urandom available)")
        elseif source == "random" then
            print("Status: SECURE (/dev/random available - may block)")
        else
            print("Status: NO SECURE SOURCE AVAILABLE")
            print("ERROR: Cannot generate cryptographically secure keys.")
            print("       Requires /dev/urandom or /dev/random.")
        end
        os.exit(secure and 0 or 1)
    elseif a == "-l" or a == "--length" then
        i = i + 1
        key_length = tonumber(arg[i])
        if not key_length or (key_length ~= 16 and key_length ~= 32) then
            io.stderr:write("Error: Key length must be 16 or 32 bytes\n")
            os.exit(1)
        end
    elseif a == "-n" or a == "--count" then
        i = i + 1
        count = tonumber(arg[i])
        if not count or count < 1 or count > 100 then
            io.stderr:write("Error: Count must be between 1 and 100\n")
            os.exit(1)
        end
    elseif a == "-f" or a == "--format" then
        i = i + 1
        format = arg[i]
        if format ~= "hex" and format ~= "base64" then
            io.stderr:write("Error: Format must be 'hex' or 'base64'\n")
            os.exit(1)
        end
    else
        io.stderr:write("Error: Unknown option: " .. a .. "\n")
        io.stderr:write("Use -h or --help for usage information\n")
        os.exit(1)
    end
    
    i = i + 1
end

-- Require secure random
if not utils.has_secure_random() then
    io.stderr:write("ERROR: No secure random source available!\n")
    io.stderr:write("       Cannot generate cryptographically secure keys.\n")
    io.stderr:write("       Requires /dev/urandom or /dev/random.\n")
    os.exit(1)
end

-- Generate keys
print(string.format("Generating %d %d-byte key%s (%s format):", 
                   count, key_length, count > 1 and "s" or "", format))
print()

for j = 1, count do
    local key = utils.random_bytes(key_length)
    local output
    
    if format == "hex" then
        output = utils.bytes_to_hex(key)
    else
        output = base64_encode(key)
    end
    
    if count > 1 then
        print(string.format("Key %2d: %s", j, output))
    else
        print(output)
    end
end

-- Show appropriate usage hint
print()
if key_length == 16 then
    print("Use with: ipcrypt.deterministic or ipcrypt.nd")
elseif key_length == 32 then
    print("Use with: ipcrypt.ndx (AES-XTS requires 32-byte key)")
end